# -*- coding: utf-8
#   utility
#   *******
#
# Utility Functions
from __future__ import print_function

import cgi
import codecs
import json
import logging
import os
import re
import sys
import traceback
import uuid
from datetime import datetime, timedelta

from globaleaks import LANGUAGES_SUPPORTED_CODES
from twisted.internet import reactor
from twisted.internet.defer import Deferred
from twisted.python import log as twlog
from twisted.python import util, failure


def get_disk_space(path):
    statvfs = os.statvfs(path)
    free_bytes = statvfs.f_frsize * statvfs.f_bavail
    total_bytes = statvfs.f_frsize * statvfs.f_blocks
    return free_bytes, total_bytes


def read_file(p):
    with file(p, 'r') as f:
        return f.read()


def read_json_file(p):
    return json.loads(read_file(p))


def uuid4():
    """
    This function returns a uuid4.

    The function is not intended to be used for security reasons.
    """
    return unicode(uuid.uuid4())


def sum_dicts(*dicts):
    ret = {}

    for d in dicts:
        for k, v in d.items():
            ret[k] = v

    return ret


def every_language_dict(default_text=''):
    return {code : default_text for code in LANGUAGES_SUPPORTED_CODES}


def deferred_sleep(timeout):
    d = Deferred()

    reactor.callLater(timeout, d.callback, True)

    return d


def msdos_encode(s):
    """
    This functions returns a new string with all occurences of newlines
    preprended with a carriage return.
    """
    return re.sub(r'(\r\n)|(\n)', '\r\n', s)


def log_encode_html(s):
    """
    This function encodes the following characters
    using HTML encoding: < > & ' " \ /
    """
    s = cgi.escape(s, True)
    s = s.replace("'", "&#39;")
    s = s.replace("/", "&#47;")
    s = s.replace("\\", "&#92;")

    return s


def log_remove_escapes(s):
    """
    This function removes escape sequence from log strings
    """
    if isinstance(s, unicode):
        return codecs.encode(s, 'unicode_escape')
    else:
        try:
            unicodelogmsg = str(s).decode('utf-8')
        except UnicodeDecodeError:
            return codecs.encode(s, 'string_escape')
        except Exception as e:
            return "Failure in log_remove_escapes %r" % e
        else:
            return codecs.encode(unicodelogmsg, 'unicode_escape')


class GLLogObserver(twlog.FileLogObserver):
    """
    Tracks and logs exceptions generated within the application
    """
    def emit(self, eventDict):
        """
        Handles formatting system log messages along with incrementing the objs
        error counters. The eventDict is generated by the arguments passed to each
        log level call. See the unittests for an example.
        """
        if 'failure' in eventDict:
            vf = eventDict['failure']
            e_t, e_v, e_tb = vf.type, vf.value, vf.getTracebackObject()
            sys.excepthook(e_t, e_v, e_tb)

        text = twlog.textFromEventDict(eventDict)
        if text is None:
            return

        timeStr = self.formatTime(eventDict['time'])
        fmtDict = {'system': eventDict['system'], 'text': text.replace("\n", "\n\t")}

        msgStr = twlog._safeFormat("[%(system)s] %(text)s\n", fmtDict)

        util.untilConcludes(self.write, timeStr + " " + log_encode_html(msgStr))
        util.untilConcludes(self.flush)


class Logger(object):
    """
    Customized LogPublisher
    """
    loglevel = logging.ERROR

    def setloglevel(self, loglevel):
        self.loglevel = loglevel

    def _print_logline(self, prefix, msg, *args):
        if not isinstance(msg, str) and not isinstance(msg, unicode):
            msg = str(msg)

        if isinstance(msg, unicode):
            msg = msg.encode('utf-8')

        msg = (msg % args) if args else msg

        msg = log_remove_escapes(msg)

        print('[' + prefix + '] ' + msg)

    def debug(self, msg, *args):
        if self.loglevel and self.loglevel <= logging.DEBUG:
            self._print_logline('D', msg, *args)

    def info(self, msg, *args):
        if self.loglevel and self.loglevel <= logging.INFO:
            self._print_logline('I', msg, *args)

    def err(self, msg, *args):
        if self.loglevel:
            self._print_logline('E', msg, *args)

    def exception(self, error):
        """
        Formats exceptions for output to logs and/or stdout

        :param error:
        :type error: Exception or `twisted.python.failure.Failure`
        """
        if isinstance(error, failure.Failure):
            error.printTraceback()
        else:
            exc_type, exc_value, exc_traceback = sys.exc_info()
            traceback.print_exception(exc_type, exc_value, exc_traceback)


log = Logger()


## time facilities ##


def datetime_null():
    """
    @return: a utc datetime object representing a null date
    """
    return datetime(1970, 1, 1, 0, 0)


def datetime_now():
    """
    @return: a utc datetime object for the current time
    """
    return datetime.utcnow()


def datetime_never():
    """
    @return: a utc datetime object representing the 1st January 3000
    """
    return datetime(3000, 1, 1, 0, 0)


def get_expiration(days):
    """
    @return: a utc datetime object representing an expiration time calculated as the current date + N days
    """
    date = datetime.utcnow()
    return datetime(year=date.year, month=date.month, day=date.day, hour=00, minute=00, second=00) + timedelta(days=days+1)


def is_expired(check_date, seconds=0, minutes=0, hours=0, day=0):
    """
    @param check_date: a datetime or a timestap
    @param seconds, minutes, hours, day
        the time to live of the element
    @return:
        if now > check_date + (seconds+minutes+hours)
        True is returned, else False
    """
    total_hours = (day * 24) + hours
    check = check_date + timedelta(seconds=seconds, minutes=minutes, hours=total_hours)

    return datetime_now() > check


def datetime_to_ISO8601(date):
    """
    conver a datetime into ISO8601 date
    """
    if date is None:
        date = datetime_null()

    return date.isoformat() + "Z" # Z means that the date is in UTC


def ISO8601_to_datetime(isodate):
    """
    convert an ISO8601 date into a datetime
    """
    isodate = isodate[:19] # we srip the eventual Z at the end

    return datetime.strptime(isodate, "%Y-%m-%dT%H:%M:%S")


def datetime_to_pretty_str(date):
    """
    print a datetime in pretty formatted str format
    """
    return date.strftime("%A %d %B %Y %H:%M (UTC)")


def ISO8601_to_day_str(isodate, tz=0):
    """
    print a ISO8601 in DD/MM/YYYY formatted str
    """
    date = datetime(year=int(isodate[0:4]),
                    month=int(isodate[5:7]),
                    day=int(isodate[8:10]),
                    hour=int(isodate[11:13]),
                    minute=int(isodate[14:16]),
                    second=int(isodate[17:19]))

    if tz != 0:
        tz_i, tz_d = divmod(tz, 1)
        tz_d, _  = divmod(tz_d * 100, 1)
        date += timedelta(hours=tz_i, minutes=tz_d)

    return date.strftime("%d/%m/%Y")


def ISO8601_to_pretty_str(isodate, tz=0):
    """
    convert a ISO8601 in pretty formatted str format
    """
    if isodate is None:
        isodate = datetime_null().isoformat()

    date = datetime(year=int(isodate[0:4]),
                    month=int(isodate[5:7]),
                    day=int(isodate[8:10]),
                    hour=int(isodate[11:13]),
                    minute=int(isodate[14:16]),
                    second=int(isodate[17:19]) )

    if tz != 0:
        tz_i, tz_d = divmod(tz, 1)
        tz_d, _  = divmod(tz_d * 100, 1)
        date += timedelta(hours=tz_i, minutes=tz_d)
        return date.strftime("%A %d %B %Y %H:%M")

    return datetime_to_pretty_str(date)


def timedelta_to_milliseconds(t):
    return (t.microseconds + (t.seconds + t.days * 24 * 3600) * 10**6) / 10**3.0


def asn1_datestr_to_datetime(s):
    """
    Returns a datetime for the passed asn1 formatted string
    """
    return datetime.strptime(s[:14], "%Y%m%d%H%M%S")


def format_cert_expr_date(s):
    """
    Takes a asn1 formatted date string and tries to create an expiration date
    out of it. If that does not work, the returned expiration date is never.
    """
    try:
        return asn1_datestr_to_datetime(s)
    except:
        return datetime_never()


def iso_year_start(iso_year):
    """Returns the gregorian calendar date of the first day of the given ISO year"""
    fourth_jan = datetime.strptime('{0}-01-04'.format(iso_year), '%Y-%m-%d')
    delta = timedelta(fourth_jan.isoweekday() - 1)
    return fourth_jan - delta


def iso_to_gregorian(iso_year, iso_week, iso_day):
    """Returns gregorian calendar date for the given ISO year, week and day"""
    year_start = iso_year_start(iso_year)
    return year_start + timedelta(days=iso_day - 1, weeks=iso_week - 1)


def bytes_to_pretty_str(b):
    if isinstance(b, str):
        b = int(b)

    if b >= 1000000000:
        return "%dGB" % int(b / 1000000000)

    if b >= 1000000:
        return "%dMB" % int(b / 1000000)

    return "%dKB" % int(b / 1000)
